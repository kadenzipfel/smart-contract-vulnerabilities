<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Smart Contract Vulnerabilities</li><li class="chapter-item expanded "><a href="vulnerabilities/insufficient-gas-griefing.html"><strong aria-hidden="true">1.</strong> Insufficient Gas Griefing</a></li><li class="chapter-item expanded "><a href="vulnerabilities/reentrancy.html"><strong aria-hidden="true">2.</strong> Reentrancy</a></li><li class="chapter-item expanded "><a href="vulnerabilities/overflow-underflow.html"><strong aria-hidden="true">3.</strong> Integer Overflow and Underflow</a></li><li class="chapter-item expanded "><a href="vulnerabilities/timestamp-dependence.html"><strong aria-hidden="true">4.</strong> Timestamp Dependence</a></li><li class="chapter-item expanded "><a href="vulnerabilities/authorization-txorigin.html"><strong aria-hidden="true">5.</strong> Authorization Through tx.origin</a></li><li class="chapter-item expanded "><a href="vulnerabilities/floating-pragma.html"><strong aria-hidden="true">6.</strong> Floating Pragma</a></li><li class="chapter-item expanded "><a href="vulnerabilities/outdated-compiler-version.html"><strong aria-hidden="true">7.</strong> Outdated Compiler Version</a></li><li class="chapter-item expanded "><a href="vulnerabilities/unsafe-low-level-call.html"><strong aria-hidden="true">8.</strong> Unsafe Low-Level Call</a></li><li class="chapter-item expanded "><a href="vulnerabilities/unchecked-return-values.html"><strong aria-hidden="true">9.</strong> Unchecked Return Value</a></li><li class="chapter-item expanded "><a href="vulnerabilities/unsupported-opcodes.html"><strong aria-hidden="true">10.</strong> Unsupported Opcodes</a></li><li class="chapter-item expanded "><a href="vulnerabilities/uninitialized-storage-pointer.html"><strong aria-hidden="true">11.</strong> Uninitialized Storage Pointer</a></li><li class="chapter-item expanded "><a href="vulnerabilities/assert-violation.html"><strong aria-hidden="true">12.</strong> Assert Violation</a></li><li class="chapter-item expanded "><a href="vulnerabilities/use-of-deprecated-functions.html"><strong aria-hidden="true">13.</strong> Use of Deprecated Functions</a></li><li class="chapter-item expanded "><a href="vulnerabilities/delegatecall-untrusted-callee.html"><strong aria-hidden="true">14.</strong> Delegatecall to Untrusted Callee</a></li><li class="chapter-item expanded "><a href="vulnerabilities/signature-malleability.html"><strong aria-hidden="true">15.</strong> Signature Malleability</a></li><li class="chapter-item expanded "><a href="vulnerabilities/incorrect-constructor.html"><strong aria-hidden="true">16.</strong> Incorrect Constructor Name</a></li><li class="chapter-item expanded "><a href="vulnerabilities/shadowing-state-variables.html"><strong aria-hidden="true">17.</strong> Shadowing State Variables</a></li><li class="chapter-item expanded "><a href="vulnerabilities/weak-sources-randomness.html"><strong aria-hidden="true">18.</strong> Weak Sources of Randomness from Chain Attributes</a></li><li class="chapter-item expanded "><a href="vulnerabilities/missing-protection-signature-replay.html"><strong aria-hidden="true">19.</strong> Missing Protection against Signature Replay Attacks</a></li><li class="chapter-item expanded "><a href="vulnerabilities/requirement-violation.html"><strong aria-hidden="true">20.</strong> Requirement Validation</a></li><li class="chapter-item expanded "><a href="vulnerabilities/arbitrary-storage-location.html"><strong aria-hidden="true">21.</strong> Write to Arbitrary Storage Location</a></li><li class="chapter-item expanded "><a href="vulnerabilities/hash-collision.html"><strong aria-hidden="true">22.</strong> Hash Collision when using abi.encodePacked() with Multiple Variable-Length Arguments</a></li><li class="chapter-item expanded "><a href="vulnerabilities/incorrect-inheritance-order.html"><strong aria-hidden="true">23.</strong> Incorrect Inheritance Order</a></li><li class="chapter-item expanded "><a href="vulnerabilities/unused-variables.html"><strong aria-hidden="true">24.</strong> Presence of Unused Variables</a></li><li class="chapter-item expanded "><a href="vulnerabilities/unencrypted-private-data-on-chain.html"><strong aria-hidden="true">25.</strong> Unencrypted Private Data On-Chain</a></li><li class="chapter-item expanded "><a href="vulnerabilities/inadherence-to-standards.html"><strong aria-hidden="true">26.</strong> Inadherence to Standards</a></li><li class="chapter-item expanded "><a href="vulnerabilities/asserting-contract-from-code-size.html"><strong aria-hidden="true">27.</strong> Asserting Contract from Code Size</a></li><li class="chapter-item expanded "><a href="vulnerabilities/transaction-ordering-dependence.html"><strong aria-hidden="true">28.</strong> Transaction-Ordering Dependence</a></li><li class="chapter-item expanded "><a href="vulnerabilities/dos-gas-limit.html"><strong aria-hidden="true">29.</strong> DoS with Block Gas Limit</a></li><li class="chapter-item expanded "><a href="vulnerabilities/dos-revert.html"><strong aria-hidden="true">30.</strong> DoS with (Unexpected) revert</a></li><li class="chapter-item expanded "><a href="vulnerabilities/unexpected-ecrecover-null-address.html"><strong aria-hidden="true">31.</strong> Unexpected ecrecover null address</a></li><li class="chapter-item expanded "><a href="vulnerabilities/default-visibility.html"><strong aria-hidden="true">32.</strong> Default Visibility</a></li><li class="chapter-item expanded "><a href="vulnerabilities/insufficient-access-control.html"><strong aria-hidden="true">33.</strong> Insufficient Access Control</a></li><li class="chapter-item expanded "><a href="vulnerabilities/off-by-one.html"><strong aria-hidden="true">34.</strong> Off-By-One</a></li><li class="chapter-item expanded "><a href="vulnerabilities/lack-of-precision.html"><strong aria-hidden="true">35.</strong> Lack of Precision</a></li><li class="chapter-item expanded "><a href="vulnerabilities/unbounded-return-data.html"><strong aria-hidden="true">36.</strong> Unbounded Return Data</a></li><li class="chapter-item expanded "><a href="vulnerabilities/msgvalue-loop.html"><strong aria-hidden="true">37.</strong> Using msg.value in a Loop</a></li><li class="chapter-item expanded "><a href="vulnerabilities/mapping-within-struct.html"><strong aria-hidden="true">38.</strong> Deleting a Mapping Within a Struct</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="smart-contract-vulnerabilities"><a class="header" href="#smart-contract-vulnerabilities">Smart Contract Vulnerabilities</a></h1>
<ul>
<li><a href="./vulnerabilities/insufficient-gas-griefing.html">Insufficient Gas Griefing</a></li>
<li><a href="./vulnerabilities/reentrancy.html">Reentrancy</a></li>
<li><a href="./vulnerabilities/overflow-underflow.html">Integer Overflow and Underflow</a></li>
<li><a href="./vulnerabilities/timestamp-dependence.html">Timestamp Dependence</a></li>
<li><a href="./vulnerabilities/authorization-txorigin.html">Authorization Through tx.origin</a></li>
<li><a href="./vulnerabilities/floating-pragma.html">Floating Pragma</a></li>
<li><a href="./vulnerabilities/outdated-compiler-version.html">Outdated Compiler Version</a></li>
<li><a href="./vulnerabilities/unsafe-low-level-call.html">Unsafe Low-Level Call</a></li>
<li><a href="./vulnerabilities/unchecked-return-values.html">Unchecked Return Value</a></li>
<li><a href="./vulnerabilities/unsupported-opcodes.html">Unsupported Opcodes</a></li>
<li><a href="./vulnerabilities/uninitialized-storage-pointer.html">Uninitialized Storage Pointer</a></li>
<li><a href="./vulnerabilities/assert-violation.html">Assert Violation</a></li>
<li><a href="./vulnerabilities/use-of-deprecated-functions.html">Use of Deprecated Functions</a></li>
<li><a href="./vulnerabilities/delegatecall-untrusted-callee.html">Delegatecall to Untrusted Callee</a></li>
<li><a href="./vulnerabilities/signature-malleability.html">Signature Malleability</a></li>
<li><a href="./vulnerabilities/incorrect-constructor.html">Incorrect Constructor Name</a></li>
<li><a href="./vulnerabilities/shadowing-state-variables.html">Shadowing State Variables</a></li>
<li><a href="./vulnerabilities/weak-sources-randomness.html">Weak Sources of Randomness from Chain Attributes</a></li>
<li><a href="./vulnerabilities/missing-protection-signature-replay.html">Missing Protection against Signature Replay Attacks</a></li>
<li><a href="./vulnerabilities/requirement-violation.html">Requirement Validation</a></li>
<li><a href="./vulnerabilities/arbitrary-storage-location.html">Write to Arbitrary Storage Location</a></li>
<li><a href="./vulnerabilities/hash-collision.html">Hash Collision when using abi.encodePacked() with Multiple Variable-Length Arguments</a></li>
<li><a href="./vulnerabilities/incorrect-inheritance-order.html">Incorrect Inheritance Order</a></li>
<li><a href="./vulnerabilities/unused-variables.html">Presence of Unused Variables</a></li>
<li><a href="./vulnerabilities/unencrypted-private-data-on-chain.html">Unencrypted Private Data On-Chain</a></li>
<li><a href="./vulnerabilities/inadherence-to-standards.html">Inadherence to Standards</a></li>
<li><a href="./vulnerabilities/asserting-contract-from-code-size.html">Asserting Contract from Code Size</a></li>
<li><a href="./vulnerabilities/transaction-ordering-dependence.html">Transaction-Ordering Dependence</a></li>
<li><a href="./vulnerabilities/dos-gas-limit.html">DoS with Block Gas Limit</a></li>
<li><a href="./vulnerabilities/dos-revert.html">DoS with (Unexpected) revert</a></li>
<li><a href="./vulnerabilities/unexpected-ecrecover-null-address.html">Unexpected <code>ecrecover</code> null address</a></li>
<li><a href="./vulnerabilities/default-visibility.html">Default Visibility</a></li>
<li><a href="./vulnerabilities/insufficient-access-control.html">Insufficient Access Control</a></li>
<li><a href="./vulnerabilities/off-by-one.html">Off-By-One</a></li>
<li><a href="./vulnerabilities/lack-of-precision.html">Lack of Precision</a></li>
<li><a href="./vulnerabilities/unbounded-return-data.html">Unbounded Return Data</a></li>
<li><a href="./vulnerabilities/msgvalue-loop.html">Using <code>msg.value</code> in a Loop</a></li>
<li><a href="./vulnerabilities/mapping-within-struct.html">Deleting a Mapping Within a Struct</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="insufficient-gas-griefing"><a class="header" href="#insufficient-gas-griefing">Insufficient Gas Griefing</a></h2>
<p>Insufficient gas griefing can be done on contracts which accept data and use it in a sub-call on another contract. This method is often used in multisignature wallets as well as transaction relayers. If the sub-call fails, either the whole transaction is reverted, or execution is continued.</p>
<p>Let's consider a simple relayer contract as an example. As shown below, the relayer contract allows someone to make and sign a transaction, without having to execute the transaction. Often this is used when a user can't pay for the gas associated with the transaction.</p>
<pre><code>contract Relayer {
    mapping (bytes =&gt; bool) executed;

    function relay(bytes _data) public {
        // replay protection; do not call the same transaction twice
        require(executed[_data] == 0, "Duplicate call");
        executed[_data] = true;
        innerContract.call(bytes4(keccak256("execute(bytes)")), _data);
    }
}
</code></pre>
<p>The user who executes the transaction, the 'forwarder', can effectively censor transactions by using just enough gas so that the transaction executes, but not enough gas for the sub-call to succeed.</p>
<p>There are two ways this could be prevented. The first solution would be to only allow trusted users to relay transactions. The other solution is to require that the forwarder provides enough gas, as seen below.</p>
<pre><code>// contract called by Relayer
contract Executor {
    function execute(bytes _data, uint _gasLimit) {
        require(gasleft() &gt;= _gasLimit);
        ...
    }
}
</code></pre>
<h3 id="sources"><a class="header" href="#sources">Sources</a></h3>
<ul>
<li><a href="https://scsfg.io/hackers/griefing/">SCSFG - Griefing</a></li>
<li><a href="https://ethereum.stackexchange.com/questions/62829/what-does-griefing-mean">Ethereum Stack Exchange - What does griefing mean?</a></li>
<li><a href="https://ethereum.stackexchange.com/questions/73261/griefing-attacks-are-they-profitable-for-the-attacker">Ethereum Stack Exchange - Griefing attacks: Are they profitable for the attacker?</a></li>
<li><a href="https://en.wikipedia.org/wiki/Griefer">Wikipedia - Griefer</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="reentrancy"><a class="header" href="#reentrancy">Reentrancy</a></h2>
<p>Reentrancy is an attack that can occur when a bug in a contract may allow a malicious contract to reenter the contract unexpectedly during execution of the original function. This can be used to drain funds from a smart contract if used maliciously. Reentrancy is likely the single most impactful vulnerability in terms of total loss of funds by smart contract hacks, and should be considered accordingly. <a href="https://github.com/pcaversaccio/reentrancy-attacks">List of reentrancy attacks</a></p>
<h3 id="external-calls"><a class="header" href="#external-calls">External calls</a></h3>
<p>Reentrancy can be executed by the availability of an external call to an attacker controlled contract. External calls allow for the callee to execute arbitrary code. The existence of an external call may not always be obvious, so it's important to be aware of any way in which an external call may be executed in your smart contracts.</p>
<h5 id="eth-transfers"><a class="header" href="#eth-transfers">ETH transfers</a></h5>
<p>When Ether is transferred to a contract address, it will trigger the <code>receive</code> or <code>fallback</code> function, as implemented in the contract. An attacker can write any arbitrary logic into the <code>fallback</code> method, such that anytime the contract receives a transfer, that logic is executed.</p>
<h5 id="safemint"><a class="header" href="#safemint"><code>safeMint</code></a></h5>
<p>One example of a hard to spot external call is OpenZeppelin's <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/3f610ebc25480bf6145e519c96e2f809996db8ed/contracts/token/ERC721/ERC721.sol#L244"><code>ERC721._safeMint</code></a> &amp; <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/3f610ebc25480bf6145e519c96e2f809996db8ed/contracts/token/ERC721/ERC721.sol#L190"><code>ERC721._safeTransfer</code></a> functions.</p>
<pre><code>/**
  * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
  * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
  */
function _safeMint(
    address to,
    uint256 tokenId,
    bytes memory _data
) internal virtual {
    _mint(to, tokenId);
    require(
        _checkOnERC721Received(address(0), to, tokenId, _data),
        "ERC721: transfer to non ERC721Receiver implementer"
    );
}
</code></pre>
<p>The function is titled <code>_safeMint</code> because it prevents tokens from being unintentionally minted to a contract by checking first whether that contract has implemented ERC721Receiver, i.e. marking itself as a willing recipient of NFTs. This all seems fine, but <code>_checkOnERC721Received</code> is an external call to the receiving contract, allowing arbitrary execution.</p>
<h3 id="single-function-reentrancy"><a class="header" href="#single-function-reentrancy">Single function reentrancy</a></h3>
<p>A single function reentrancy attack occurs when a vulnerable function is the same function that an attacker is trying to recursively call.</p>
<pre><code>// UNSECURE
function withdraw() external {
    uint256 amount = balances[msg.sender];
    (bool success,) = msg.sender.call{value: balances[msg.sender]}("");
    require(success);
    balances[msg.sender] = 0;
}
</code></pre>
<p>Here we can see that the balance is only modified after the funds have been transferred. This can allow a hacker to call the function many times before the balance is set to 0, effectively draining the smart contract.</p>
<h3 id="cross-function-reentrancy"><a class="header" href="#cross-function-reentrancy">Cross-function reentrancy</a></h3>
<p>A cross-function reentrancy attack is a more complex version of the same process. Cross-function reentrancy occurs when a vulnerable function shares state with a function that an attacker can exploit.</p>
<pre><code>// UNSECURE
function transfer(address to, uint amount) external {
  if (balances[msg.sender] &gt;= amount) {
    balances[to] += amount;
    balances[msg.sender] -= amount;
  }
}

function withdraw() external {
  uint256 amount = balances[msg.sender];
  (bool success,) = msg.sender.call{value: balances[msg.sender]}("");
  require(success);
  balances[msg.sender] = 0;
}
</code></pre>
<p>In this example, a hacker can exploit this contract by having a fallback function call <code>transfer()</code> to transfer spent funds before the balance is set to 0 in the <code>withdraw()</code> function.</p>
<h3 id="read-only-reentrancy"><a class="header" href="#read-only-reentrancy">Read-only Reentrancy</a></h3>
<p>Read-only reentrancy is a novel attack vector in which instead of reentering into the same contract in which state changes have yet to be made, an attacker reenters into another contract which reads from the state of the original contract.</p>
<pre><code>// UNSECURE
contract A {
	// Has a reentrancy guard to prevent reentrancy
	// but makes state change only after external call to sender
	function withdraw() external nonReentrant {
		uint256 amount = balances[msg.sender];
		(bool success,) = msg.sender.call{value: balances[msg.sender]}("");
		require(success);
		balances[msg.sender] = 0;
	}
}

contract B {
	// Allows sender to claim equivalent B tokens for A tokens they hold
	function claim() external nonReentrant {
		require(!claimed[msg.sender]);
		balances[msg.sender] = A.balances[msg.sender];
		claimed[msg.sender] = true;
	}
}
</code></pre>
<p>As we can see in the above example, although both functions have a nonReentrant modifier, it is still possible for an attacker to call <code>B.claim</code> during the callback in <code>A.withdraw</code>, and since the attackers balance was not yet updated, execution succeeds.</p>
<h3 id="reentrancy-prevention"><a class="header" href="#reentrancy-prevention">Reentrancy prevention</a></h3>
<p>The simplest reentrancy prevention mechanism is to use a <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol"><code>ReentrancyGuard</code></a>, which allows you to add a modifier, e.g. <code>nonReentrant</code>, to functions which may otherwise be vulnerable. Although effective against most forms of reentrancy, it's important to understand how read-only reentrancy may be used to get around this and to always use the <strong>checks-effects-interactions pattern</strong>.</p>
<p>For optimum security, use the <strong>checks-effects-interactions pattern</strong>. This is a simple rule of thumb for ordering smart contract functions.</p>
<p>The function should begin with <em>checks</em>, e.g. <code>require</code> and <code>assert</code> statements.</p>
<p>Next, the <em>effects</em> of the contract should be performed, i.e. state modifications.</p>
<p>Finally, we can perform <em>interactions</em> with other smart contracts, e.g. external function calls.</p>
<p>This structure is effective against reentrancy because when an attacker reenters the function, the state changes have already been made. For example:</p>
<pre><code>function withdraw() external {
  uint256 amount = balances[msg.sender];
  balances[msg.sender] = 0;
  (bool success,) = msg.sender.call{value: balances[msg.sender]}("");
  require(success);
}
</code></pre>
<p>Since the balance is set to 0 before any interactions are performed, if the contract is called recursively, there is nothing to send after the first transaction.</p>
<p>Examples from: https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21</p>
<h3 id="sources-1"><a class="header" href="#sources-1">Sources</a></h3>
<ul>
<li><a href="https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/">Reentrancy Attacks on Smart Contracts: Best Practices for Pentesters</a></li>
<li><a href="https://medium.com/@gus_tavo_guim/reentrancy-attack-on-smart-contracts-how-to-identify-the-exploitable-and-an-example-of-an-attack-4470a2d8dfe4">Reentrancy attack on Smart Contracts: How to identify the exploitable and an example of an attack</a></li>
<li><a href="https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21">Protect Your Solidity Smart Contracts From Reentrancy Attacks</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="integer-overflow-and-underflow"><a class="header" href="#integer-overflow-and-underflow">Integer Overflow and Underflow</a></h2>
<p>In solidity, Integer types have maximum and minimum values. Integer overflow occurs when an integer variable exceeds the maximum value that can be stored in that variable type. Similarly, Integer underflow occurs when an integer variable goes below the minimum value for that variable type. Example: The maximum value <code>uint8</code> can store is <code>255</code>. Now, when you store <code>256</code> in <code>uint8</code> it will overflow and the value will reset to 0. When you store <code>257</code>, the value will be <code>1</code>, <code>2</code> for <code>258</code> and so on. Similarly, if you try to store <code>-1</code> in the uint8 variable the value of the variable will become <code>255</code>, and so on as it will underflow.</p>
<p>Some integer types and their min/max values:</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Max</th><th>Min</th></tr></thead><tbody>
<tr><td>uint8</td><td>255</td><td>0</td></tr>
<tr><td>uint16</td><td>65535</td><td>0</td></tr>
<tr><td>uint24</td><td>16777215</td><td>0</td></tr>
<tr><td>uint256</td><td>2^256 - 1</td><td>0</td></tr>
</tbody></table>
</div>
<p>Since smaller integer types like: <code>uint8</code>, <code>uint16</code>, etc have smaller maximum values, it can be easier to cause an overflow, thus they should be used with greater caution.</p>
<p>To prevent over/underflows, <a href="https://github.com/ConsenSysMesh/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol">Safe Math Library</a> is often used by contracts with older versions of Solidity but Solidity &gt;=0.8 protects against integer overflows and underflows through the use of built-in safe math functions. It's important to consider that regardless of SafeMath logic being used, either built-in or used manually in older contracts, over/underflows still trigger reverts, which may result in <a href="https://github.com/kadenzipfel/smart-contract-vulnerabilities/blob/master/vulnerabilities/dos-revert.md">denial of service</a> of important functionality or other unexpected effects. Even after the update of solidity to 0.8, there are scenarios in which the integer overflow and underflow can still occur without the transaction reverting.</p>
<h3 id="typecasting"><a class="header" href="#typecasting">Typecasting</a></h3>
<p>The most common way in which integer over/underflow is possible when you convert an integer of a larger uint data type to a smaller data type.</p>
<pre><code class="language-solidity">uint256 public a = 258;
uint8 public b = uint8(a); // typecasting uint256 to uint8
</code></pre>
<p>The above code snippet will overflow and the <code>2</code> will be stored in the variable <code>b</code> due to the fact that maximum value in uint8 data type is <code>255</code>. So, it will overflow and reset to <code>0</code> without reverting.</p>
<h3 id="using-shift-operators"><a class="header" href="#using-shift-operators">Using Shift Operators</a></h3>
<p>Overflow &amp; underflow checks are not performed for shift operations like they are performed for other arithmetic operations. Thus, over/underflows can occur.</p>
<p>The left shift <code>&lt;&lt;</code> operator shifts all the beats in the first operand by the number specified in the second operand. Shifting an operand by 1 position is equivalent to multiplying it by 2, shifting 2 positions is equivalent to multiplying it by 4, and shifting 3 positions is equivalent to multiplying by 8.</p>
<pre><code class="language-solidity">uint8 public a = 100;
uint8 public b = 2;

uint8 public c = a &lt;&lt; b; // overflow as 100 * 4 &gt; 255
</code></pre>
<p>In the above code, left shifting <code>a</code> which is <code>100</code> by 2 positions <code>b</code> is equivalent to multiplying 100 by 4. So the result will overflow and the value in c will be <code>144</code> because <code>400-256</code> is <code>144</code>.</p>
<h3 id="use-of-inline-assembly"><a class="header" href="#use-of-inline-assembly">Use of Inline Assembly:</a></h3>
<p>Inline Assembly in solidity is performed using YUL language. In YUL programming language, integer underflow &amp; overflow is possible as compiler does not check automatically for it as YUL is a low-level language that is mostly used for making the code more optimized, which does this by omitting many opcodes.</p>
<pre><code class="language-solidity">uint8 public a = 255;

function addition() public returns (uint8 result) {
    assembly {
        result := add(sload(a.slot), 1) // adding 1 will overflow and reset to 0
        // using inline assembly
    }

    return result;
}
</code></pre>
<p>In the above code we are adding <code>1</code> into the variable with inline assembly and then returning the result. The variable result will overflow and 0 will be returned, despite this the contract will not throw an error or revert.</p>
<h3 id="use-of-unchecked-code-block"><a class="header" href="#use-of-unchecked-code-block">Use of unchecked code block:</a></h3>
<p>Performing arithmetic operations inside the unchecked block saves a lot of gas because it omits several checks and opcodes. But, some of these opcodes are used in default arithmetic operations in 0.8 to check for underflow/overflow.</p>
<pre><code class="language-solidity">uint8 public a = 255;

function uncheck() public{

  unchecked {
      a++;  // overflow and reset to 0 without reverting
  }

}
</code></pre>
<p>The unchecked code block is only recommended if you are sure that there is no possible way for the arithmetic to overflow or underflow.</p>
<h3 id="sources-2"><a class="header" href="#sources-2">Sources</a></h3>
<ul>
<li><a href="https://docs.soliditylang.org/en/latest/080-breaking-changes.html">Solidity Documentation - 0.8.0 Breaking Changes</a></li>
<li><a href="https://faizannehal.medium.com/how-solidity-0-8-protect-against-integer-underflow-overflow-and-how-they-can-still-happen-7be22c4ab92f">Medium - How Solidity 0.8 Protects Against Integer Underflow/Overflow and How They Can Still Happen</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="timestamp-dependence"><a class="header" href="#timestamp-dependence">Timestamp Dependence</a></h2>
<p><strong>NOTE: This vulnerability no longer affects Ethereum mainnet as of the Proof of Stake merge. <a href="https://ethereum.stackexchange.com/a/140818">Read more</a></strong></p>
<p>The timestamp of a block, accessed by <code>block.timestamp</code> or alias <code>now</code> can be manipulated by a miner. There are three considerations you should take into account when using a timestamp to execute a contract function.</p>
<h3 id="timestamp-manipulation"><a class="header" href="#timestamp-manipulation">Timestamp Manipulation</a></h3>
<p>If a timestamp is used in an attempt to generate randomness, a miner can post a timestamp within 15 seconds of block validation, giving them the ability to set the timestamp as a value that would increase their odds of benefitting from the function.</p>
<p>For example, a lottery application may use the block timestamp to pick a random bidder in a group. A miner may enter the lottery then modify the timestamp to a value that gives them better odds at winning the lottery.</p>
<p>Timestamps should thus not be used to create randomness. See <a href="vulnerabilities/weak-sources-randomness.html">Weak Sources of Randomness for Chain Attributes</a>.</p>
<h3 id="the-15-second-rule"><a class="header" href="#the-15-second-rule">The 15-second Rule</a></h3>
<p>Ethereum's reference specification, the Yellow Paper, doesn't specify a limit as to how much blocks can change in time, it just has to be bigger than the timestamp of its parent. This being said, popular protocol implementations reject blocks with timestamps greater than 15 seconds in the future, so as long as your time-dependent event can safely vary by 15 seconds, it may be safe to use a block timestamp.</p>
<h3 id="dont-use-blocknumber-as-a-timestamp"><a class="header" href="#dont-use-blocknumber-as-a-timestamp">Don't use <code>block.number</code> as a timestamp</a></h3>
<p>You can estimate the time difference between events using <code>block.number</code> and the average block time, but block times may change and break the functionality, so it's best to avoid this use.</p>
<h3 id="sources-3"><a class="header" href="#sources-3">Sources</a></h3>
<ul>
<li><a href="https://consensys.github.io/smart-contract-best-practices/attacks/timestamp-dependence/">Consensys Smart Contract Best Practices - Timestamp Dependence (Attacks)</a></li>
<li><a href="https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/timestamp-dependence/">Consensys Smart Contract Best Practices - Timestamp Dependence (Development Recommendations)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="authorization-through-txorigin"><a class="header" href="#authorization-through-txorigin">Authorization Through tx.origin</a></h2>
<p><code>tx.origin</code> is a global variable in Solidity which returns the address that sent a transaction. It's important that you never use <code>tx.origin</code> for authorization since another contract can use a fallback function to call your contract and gain authorization since the authorized address is stored in <code>tx.origin</code>. Consider this example:</p>
<pre><code>pragma solidity &gt;=0.5.0 &lt;0.7.0;

// THIS CONTRACT CONTAINS A BUG - DO NOT USE
contract TxUserWallet {
    address owner;

    constructor() public {
        owner = msg.sender;
    }

    function transferTo(address payable dest, uint amount) public {
        require(tx.origin == owner);
        dest.transfer(amount);
    }
}
</code></pre>
<p>Here we can see that the <code>TxUserWallet</code> contract authorizes the <code>transferTo()</code> function with <code>tx.origin</code>.</p>
<pre><code>pragma solidity &gt;=0.5.0 &lt;0.7.0;

interface TxUserWallet {
    function transferTo(address payable dest, uint amount) external;
}

contract TxAttackWallet {
    address payable owner;

    constructor() public {
        owner = msg.sender;
    }

    function() external {
        TxUserWallet(msg.sender).transferTo(owner, msg.sender.balance);
    }
}
</code></pre>
<p>Now if someone were to trick you into sending ether to the <code>TxAttackWallet</code> contract address, they can steal your funds by checking <code>tx.origin</code> to find the address that sent the transaction.</p>
<p>To prevent this kind of attack, use <code>msg.sender</code> for authorization.</p>
<p>Examples from: https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin</p>
<h3 id="sources-4"><a class="header" href="#sources-4">Sources</a></h3>
<ul>
<li><a href="https://swcregistry.io/docs/SWC-115">SWC-115</a></li>
<li><a href="https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin">Solidity Security Considerations - tx.origin</a></li>
<li><a href="https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/tx-origin/">Consensys Smart Contract Best Practices - tx.origin</a></li>
<li><a href="https://github.com/sigp/solidity-security-blog#tx-origin">SigP Solidity Security Blog - tx.origin</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="floating-pragma"><a class="header" href="#floating-pragma">Floating Pragma</a></h2>
<p>It is considered best practice to pick one compiler version and stick with it. With a floating pragma, contracts may accidentally be deployed using an outdated or problematic compiler version which can cause bugs, putting your smart contract's security in jeopardy. For open-source projects, the pragma also tells developers which version to use, should they deploy your contract. The chosen compiler version should be thoroughly tested and considered for known bugs.</p>
<p>The exception in which it is acceptable to use a floating pragma, is in the case of libraries and packages. Otherwise, developers would need to manually update the pragma to compile locally.</p>
<h3 id="sources-5"><a class="header" href="#sources-5">Sources</a></h3>
<ul>
<li><a href="https://swcregistry.io/docs/SWC-103">SWC-103</a></li>
<li><a href="https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/locking-pragmas/">Consensys Smart Contract Best Practices - Locking Pragmas</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="outdated-compiler-version"><a class="header" href="#outdated-compiler-version">Outdated Compiler Version</a></h2>
<p>Developers often find bugs and vulnerabilities in existing software and make patches. For this reason, it's important to use the most recent compiler version possible. See bugs from past compiler versions <a href="https://solidity.readthedocs.io/en/latest/bugs.html">here</a>.</p>
<h3 id="sources-6"><a class="header" href="#sources-6">Sources</a></h3>
<ul>
<li><a href="https://swcregistry.io/docs/SWC-102">SWC-102</a></li>
<li><a href="https://github.com/ethereum/solidity/releases">Ethereum Solidity Releases</a></li>
<li><a href="https://etherscan.io/solcbuginfo">Etherscan Solidity Bug Info</a></li>
<li><a href="https://solidity.readthedocs.io/en/latest/bugs.html">Solidity Documentation - Bugs</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unsafe-low-level-call"><a class="header" href="#unsafe-low-level-call">Unsafe Low-Level Call</a></h2>
<p>In Solidity, you can either use low-level calls such as: <code>address.call()</code>, <code>address.callcode()</code>, <code>address.delegatecall()</code>, and <code>address.send()</code>; or you can use contract calls such as: <code>ExternalContract.doSomething()</code>.</p>
<p>Low-level calls can be a good way to efficiently or arbitrarily make contract calls. However, it's important to be aware of the caveats it possesses.</p>
<h3 id="unchecked-call-return-value"><a class="header" href="#unchecked-call-return-value">Unchecked call return value</a></h3>
<p>Low-level calls will never throw an exception, instead they will return <code>false</code> if they encounter an exception, whereas contract calls will automatically throw. Thus if the return value of a low-level call is not checked, the execution may resume even if the function call throws an error. This can lead to unexpected behaviour and break the program logic. A failed call can even be caused intentionally by an attacker, who may be able to further exploit the application.</p>
<p>In the case that you use low-level calls, be sure to check the return value to handle possible failed calls, e.g.:</p>
<pre><code>// Simple transfer of 1 ether
(bool success,) = to.call{value: 1 ether}("");
// Revert if unsuccessful
require(success);
</code></pre>
<h3 id="successful-call-to-non-existent-contract"><a class="header" href="#successful-call-to-non-existent-contract">Successful call to non-existent contract</a></h3>
<p>As noted in the <a href="https://docs.soliditylang.org/en/v0.8.15/control-structures.html?highlight=low%20level%20calls#external-function-calls">Solidity docs</a>: "Due to the fact that the EVM considers a call to a non-existing contract to always succeed, Solidity uses the <code>extcodesize</code> opcode to check that the contract that is about to be called actually exists (it contains code) and causes an exception if it does not. This check is skipped if the return data will be decoded after the call and thus the ABI decoder will catch the case of a non-existing contract.</p>
<p>Note that this check is not performed in case of <a href="https://docs.soliditylang.org/en/v0.8.15/units-and-global-variables.html#address-related">low-level calls</a> which operate on addresses rather than contract instances."</p>
<p>It's imperative that we do not simply assume that a contract to be called via a low-level call actually exists, since if it doesn't our logic will proceed even though our external call effectively failed. This can lead to loss of funds and/or an invalid contract state. Instead, we must verify that the contract being called exists, either immediately before being called with an <code>extcodesize</code> check, or by verifying during contract deployment and using a <code>constant</code>/<code>immutable</code> value if the contract can be fully trusted.</p>
<pre><code>// Verify address is a contract
require(to.code.length &gt; 0);
// Simple transfer of 1 ether
(bool success,) = to.call{value: 1 ether}("");
// Revert if unsuccessful
require(success);
</code></pre>
<h3 id="sources-7"><a class="header" href="#sources-7">Sources</a></h3>
<ul>
<li><a href="https://swcregistry.io/docs/SWC-104">SWC-104: Record Replay</a></li>
<li><a href="https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/external-calls/">Consensys Smart Contract Best Practices - External Calls</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="unchecked-return-values"><a class="header" href="#unchecked-return-values">Unchecked Return Values</a></h3>
<p>The main idea behind this type of vulnerability is the failure to properly handle the return values of external function calls. This can have significant consequences, including fund loss and unexpected behavior in the contract's logic.</p>
<p>In Solidity, developers can perform external calls using methods like:</p>
<ol>
<li><code>.send()</code></li>
<li><code>.call()</code></li>
<li><code>.transfer()</code></li>
</ol>
<p><code>.transfer()</code> is commonly used to send ether to external accounts, however, the <code>.send()</code> function can also be used. For more versatile external calls, <code>.call()</code> can be used.</p>
<p>Each of these methods has a different behavior when it comes to error handling. The <code>.call()</code> and <code>.send()</code> functions return a boolean indicating if the call succeeded or failed. Thus, these functions have a simple caveat: the transaction that executes these functions (<code>.call()</code> and <code>.send()</code>) WILL NOT revert if the external call fails. Instead, <code>.call()</code> and <code>.send()</code> will simply return the boolean value <code>false</code>.</p>
<p>A common pitfall arises when the return value is not checked, as the developer expects a revert to occur when, in reality, the revert will not occur if not explicitly checked by the smart contract.</p>
<p>For example, if a contract uses <code>.send()</code> without checking its return value, transaction execution will continue even if the call fails, resulting in unexpected behavior. Take the below contract for example:</p>
<pre><code class="language-solidity">/// INSECURE
contract Lotto {

    bool public paidOut = false;
    address public winner;
    uint256 public winAmount;

    /// extra functionality here

    function sendToWinner() public {
        require(!paidOut);
        winner.send(winAmount);
        paidOut = true;
    }

    function withdrawLeftOver() public {
        require(paidOut);                // requires `paidOut` to be true
        msg.sender.send(this.balance);
    }
}
</code></pre>
<p>The above contract represents a Lotto-like contract, where a winner receives <code>winAmount</code> of ether, which typically leaves a little left over for anyone to withdraw.</p>
<p>The bug exists where <code>.send()</code> is used without checking the response, i.e., <code>winner.send(winAmount)</code>.</p>
<p>In this example, a winner whose transaction fails (either by running out of gas or being a contract that intentionally throws in the fallback function) will still allow <code>paidOut</code> to be set to true (regardless of whether ether was sent or not).</p>
<p>In this case, anyone can withdraw the winner's winnings using the <code>withdrawLeftOver()</code> function.</p>
<p>A more serious version of this bug occurred in <a href="https://www.kingoftheether.com/thrones/kingoftheether/index.html">King of the Ether</a>. An excellent <a href="https://www.kingoftheether.com/postmortem.html">post-mortem</a> of this contract has been written, detailing how an unchecked failed <code>.send()</code> could be used to attack a contract.</p>
<h3 id="preventive-techniques"><a class="header" href="#preventive-techniques">Preventive Techniques</a></h3>
<p>To mitigate this vulnerability, developers should always check the return value of any call to an external contract. The <code>require()</code> function can be used to check if the call was successful and handle any errors that may occur.</p>
<p>A caveat developers should be wary of when using the <code>require()</code> function is unexpected reverts that can cause DoS. If the developer naively decides to check for the success or failure of the external <code>.send()</code> call like so:</p>
<pre><code class="language-solidity">/// INSECURE
contract Lotto {

    bool public paidOut = false;
    address public winner;
    uint256 public winAmount;

    /// extra functionality here

  function sendToWinner() public {
        require(!paidOut);
        require(winner.send(winAmount));        // naively check success of the external call
        paidOut = true;
    }

  function withdrawLeftOver() public {
        require(paidOut);                       // requires `paidOut` to be true
        msg.sender.send(this.balance);
    }
</code></pre>
<p>An attacker interacting with the <code>Lotto</code> contract from their own malicious contract and calling the <code>sendToWinner</code> function, can just implement a fallback function that reverts all payments making <code>paidOut</code> not set to true!</p>
<p>A detailed explanation of this caveat can be found <a href="vulnerabilities/./dos-revert.html">here</a></p>
<h3 id="sources-8"><a class="header" href="#sources-8">Sources</a></h3>
<ul>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#unchecked-calls">SigmaPrime blog post</a></li>
<li><a href="vulnerabilities/./dos-revert.html">DoS with an unexpected revert</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsupported-opcodes"><a class="header" href="#unsupported-opcodes">Unsupported Opcodes</a></h1>
<p>EVM-compatible chains, such as zkSync Era, BNB Chain, Polygon, Optimism and Arbitrum implement the Ethereum Virtual Machine (EVM) and its opcodes. However, opcode support can vary across these chains, which can lead to bugs and issues if not considered during smart contract development and deployment.</p>
<h2 id="push0-opcode-compatibility"><a class="header" href="#push0-opcode-compatibility">PUSH0 Opcode Compatibility</a></h2>
<p>The <code>PUSH0</code> opcode was introduced during the Shanghai hard fork of the Shapella upgrade (Solidity v0.8.20) and is available in certain EVM-compatible chains. However, not all chains have implemented support for this opcode yet.</p>
<h3 id="is-push0-supported"><a class="header" href="#is-push0-supported">Is <code>PUSH0</code> supported:</a></h3>
<ol>
<li>Ethereum: YES</li>
<li>Arbitrum One: YES</li>
<li>Optimism: YES</li>
<li>...</li>
</ol>
<p>More chain differences and opcode support can be found on: <a href="https://www.evmdiff.com">evmdiff.com</a></p>
<p>You can also check compatibility by running the following command assuming you have Foundry set up:</p>
<pre><code class="language-bash">cast call --rpc-url $ARBITRUM_RPC_URL --create 0x5f
</code></pre>
<p>Getting a <code>0x</code> response from running the above command means the opcode is supported; an error indicates the opcode isn't supported on that chain.</p>
<h2 id="create-and-create2-on-zksync-era"><a class="header" href="#create-and-create2-on-zksync-era">CREATE and CREATE2 on zkSync Era</a></h2>
<p>On zkSync Era, contract deployment uses the hash of the bytecode and the <code>factoryDeps</code> field of EIP712 transactions contains the bytecode. The actual deployment occurs by providing the contract's hash to the <code>ContractDeployer</code> system contract.</p>
<p>To ensure that <code>create</code> and <code>create2</code> functions operate correctly, the compiler MUST be aware of the bytecode of the deployed contract in advance. The compiler interprets the calldata arguments as incomplete input for <code>ContractDeployer</code>, with the remaining part filled in by the compiler internally. The Yul <code>datasize</code> and <code>dataoffset</code> instructions have been adjusted to return the constant size and bytecode hash rather than the bytecode itself.</p>
<p>The following code will not function correctly because the compiler is not aware of the bytecode beforehand but will work fine on Ethereum Mainnet:</p>
<pre><code class="language-solidity">function myFactory(bytes memory bytecode) public {
   assembly {
      addr := create(0, add(bytecode, 0x20), mload(bytecode))
   }
}
</code></pre>
<h2 id="transfer-on-zksync-era"><a class="header" href="#transfer-on-zksync-era"><code>.transfer()</code> on zkSync Era</a></h2>
<p>The <code>transfer()</code> function in Solidity is limited to 2300 gas, which can be insufficient if the receiving contract's fallback or receive function involves more complex logic. This can lead to the transaction reverting if the gas limit is exceeded.</p>
<p>It is for this exact reason that the Gemholic project on zkSync Era locked its 921 ETH that was raised during the Gemholic token sale making the funds inaccessible.</p>
<p>This was because the contract deployment did not account for zkSync Era's handling of the <code>.transfer()</code> function.</p>
<h3 id="sources-9"><a class="header" href="#sources-9">Sources</a></h3>
<ul>
<li><a href="https://docs.zksync.io/build/developer-reference/differences-with-ethereum.html#create-create2">zkSync Era docs</a></li>
<li><a href="https://www.codehawks.com/submissions/clomptuvr0001ie09bzfp4nqw/4">CodeHawks first flight submission: The TokenFactory.sol can't deploy on the ZKSync Era</a></li>
<li><a href="https://medium.com/coinmonks/gemstoneido-contract-stuck-with-921-eth-an-analysis-of-why-transfer-does-not-work-on-zksync-era-d5a01807227d">GemstoneIDO Contract Issue Analysis on Medium</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="uninitialized-storage-pointer"><a class="header" href="#uninitialized-storage-pointer">Uninitialized Storage Pointer</a></h2>
<blockquote>
<p>[!NOTE]<br />
As of solidity <code>0.5.0</code>, uninitialized storage pointers are no longer an issue since contracts with uninitialized storage pointers will no longer compile. This being said, it's still important to understand what storage pointers you should be using in certain situations.</p>
</blockquote>
<p>Data is stored in the EVM as either <code>storage</code>, <code>memory</code>, or <code>calldata</code>. It is important that they are well understood and correctly initialized. Incorrectly initializing data storage pointers, or simply leaving them uninitialized, can lead to contract vulnerabilities.</p>
<h3 id="sources-10"><a class="header" href="#sources-10">Sources</a></h3>
<ul>
<li><a href="https://swcregistry.io/docs/SWC-109">SWC-109: Arbitrary Storage Write</a></li>
<li><a href="https://github.com/sigp/solidity-security-blog#storage">Solidity Security Blog - Storage</a></li>
<li><a href="https://solidity.readthedocs.io/en/latest/types.html#data-location">Solidity Documentation: Data Location</a></li>
<li><a href="https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html">Solidity Documentation: Layout in Storage</a></li>
<li><a href="https://docs.soliditylang.org/en/latest/internals/layout_in_memory.html">Solidity Documentation: Layout in Memory</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="assert-violation"><a class="header" href="#assert-violation">Assert Violation</a></h2>
<p>In Solidity <code>0.4.10</code>, the following functions were created: <code>assert()</code>, <code>require()</code>, and <code>revert()</code>. Here we'll discuss the assert function and how to use it.</p>
<p>Formally said, the <code>assert()</code> function is meant to assert invariants; informally said, <code>assert()</code> is an overly assertive bodyguard that protects your contract, but steals your gas in the process. Properly functioning contracts should never reach a failing assert statement. If you've reached a failing assert statement, you've either improperly used <code>assert()</code>, or there is a bug in your contract that puts it in an invalid state.</p>
<p>If the condition checked in the <code>assert()</code> is not actually an invariant, it's suggested that you replace it with a <code>require()</code> statement.</p>
<h3 id="sources-11"><a class="header" href="#sources-11">Sources</a></h3>
<ul>
<li><a href="https://swcregistry.io/docs/SWC-110">SWC-110</a></li>
<li><a href="https://medium.com/blockchannel/the-use-of-revert-assert-and-require-in-solidity-and-the-new-revert-opcode-in-the-evm-1a3a7990e06e">The Use of revert, assert, and require in Solidity and the New REVERT Opcode in the EVM</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="use-of-deprecated-functions"><a class="header" href="#use-of-deprecated-functions">Use of Deprecated Functions</a></h2>
<p>As time goes by, functions and operators in Solidity are deprecated and often replaced. It's important to not use deprecated functions, as it can lead to unexpected effects and compilation errors.</p>
<p>Here is a <em>non-exhaustive</em> list of deprecated functions and alternatives. Many alternatives are simply aliases, and won't break current behaviour if used as a replacement for its deprecated counterpart.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Deprecated</th><th style="text-align: right">Alternatives</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>suicide(address)</code>/<code>selfdestruct(address)</code></td><td style="text-align: right">N/A</td></tr>
<tr><td style="text-align: left"><code>block.blockhash(uint)</code></td><td style="text-align: right"><code>blockhash(uint)</code></td></tr>
<tr><td style="text-align: left"><code>sha3(...)</code></td><td style="text-align: right"><code>keccak256(...)</code></td></tr>
<tr><td style="text-align: left"><code>callcode(...)</code></td><td style="text-align: right"><code>delegatecall(...)</code></td></tr>
<tr><td style="text-align: left"><code>throw</code></td><td style="text-align: right"><code>revert()</code></td></tr>
<tr><td style="text-align: left"><code>msg.gas</code></td><td style="text-align: right"><code>gasleft</code></td></tr>
<tr><td style="text-align: left"><code>constant</code></td><td style="text-align: right"><code>view</code></td></tr>
<tr><td style="text-align: left"><code>var</code></td><td style="text-align: right"><code>corresponding type name</code></td></tr>
</tbody></table>
</div>
<h3 id="sources-12"><a class="header" href="#sources-12">Sources</a></h3>
<ul>
<li><a href="https://swcregistry.io/docs/SWC-111">SWC-111: Use of Deprecated Solidity Features</a></li>
<li><a href="https://github.com/ethereum/solidity/releases">Solidity Releases on GitHub</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="delegatecall-to-untrusted-callee"><a class="header" href="#delegatecall-to-untrusted-callee">Delegatecall to Untrusted Callee</a></h2>
<p><code>Delegatecall</code> is a special variant of a message call. It is almost identical to a regular message call except the target address is executed in the context of the calling contract and <code>msg.sender</code> and <code>msg.value</code> remain the same. Essentially, <code>delegatecall</code> delegates other contracts to modify the calling contract's storage.</p>
<p>Since <code>delegatecall</code> gives so much control over a contract, it's very important to only use this with trusted contracts such as your own. If the target address comes from user input, be sure to verify that it is a trusted contract.</p>
<h3 id="sources-13"><a class="header" href="#sources-13">Sources</a></h3>
<ul>
<li><a href="https://swcregistry.io/docs/SWC-112">SWC Registry: SWC-112</a></li>
<li><a href="https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#delegatecall-and-libraries">Solidity Documentation: Delegatecall</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#delegatecall">Sigma Prime: Solidity Security</a></li>
<li><a href="https://ethereum.stackexchange.com/questions/3667/difference-between-call-callcode-and-delegatecall">Ethereum Stack Exchange: Difference Between Call, Callcode, and Delegatecall</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="signature-malleability"><a class="header" href="#signature-malleability">Signature Malleability</a></h2>
<p>It's generally assumed that a valid signature cannot be modified without the private key and remain valid. However, it is possible to modify and signature and maintain validity. One example of a system which is vulnerable to signature malleability is one in which validation as to whether an action can be executed is determined based on whether the signature has been previously used.</p>
<pre><code>// UNSECURE
require(!signatureUsed[signature]);

// Validate signer and perform state modifying logic
...

signatureUsed[signature] = true;
</code></pre>
<p>In the above example, we can see that the <code>signature</code> is saved in a <code>signatureUsed</code> mapping after execution and validated to not exist in that mapping before execution. The problem with this is that if the <code>signature</code> can be modified while maintaining validity, the transaction can be repeated by an attacker.</p>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h3>
<p>To understand how signature malleability works, we first need to understand a bit about elliptic curve cryptography.</p>
<p>An elliptic curve consists of all the points that satisfy an equation of the form:</p>
<p>$y^2 = x^3 + ax + b$</p>
<p>where</p>
<p>$4a^3 + 27b^2 \not= 0$ (to avoid singular points)</p>
<p>Some examples:</p>
<p><img src="vulnerabilities/./img/elliptic-curves.png" alt="Elliptic Curves" /></p>
<p>Note that the curves are always symmetrical about the x-axis</p>
<p>The curve used by Ethereum is secp256k1, which looks like this:</p>
<p><img src="vulnerabilities/./img/secp256k1.png" alt="secp256k1" /></p>
<p>Now that we understand the basics of elliptic curve cryptography, we can dig into how signature malleability actually works on Ethereum.</p>
<p>Ethereum uses <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">ECDSA</a> as its signature scheme. ECDSA signatures consist of a pair of numbers, $(r, s)$, with an integer order $n$. As a result of the x-axis symmetry, if $(r, s)$ is a valid signature, then so is $(r, -s$ mod $n)$.</p>
<p>It's possible to calculate this complementary signature without knowing the private key used to produce it in the first place, which gives an attacker the ability to produce a second valid signature.</p>
<h3 id="mitigation"><a class="header" href="#mitigation">Mitigation</a></h3>
<p>To avoid this issue, it's imperative to recognize that validating that a signature is not reused is insufficient in enforcing that the transaction is not replayed.</p>
<h3 id="sources-14"><a class="header" href="#sources-14">Sources</a></h3>
<ul>
<li><a href="https://swcregistry.io/docs/SWC-117">SWC-117</a></li>
<li><a href="https://eklitzke.org/bitcoin-transaction-malleability">Bitcoin Transaction Malleability</a></li>
<li><a href="https://hackernoon.com/what-is-the-math-behind-elliptic-curve-cryptography-f61b25253da3">The Math Behind Elliptic Curve Cryptography</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="incorrect-constructor-name"><a class="header" href="#incorrect-constructor-name">Incorrect Constructor Name</a></h2>
<blockquote>
<p>[!NOTE]<br />
This vulnerability is relevant to older contracts using Solidity versions before <code>0.4.22</code>. Modern Solidity versions (0.4.22 and later) use the <code>constructor</code> keyword, effectively deprecating this vulnerability. However, it is still important to be aware of this issue when reviewing or interacting with legacy contracts.</p>
</blockquote>
<p>Before Solidity <code>0.4.22</code>, the only way to define a constructor was by creating a function with the contract name. In some cases this was problematic. For example, if a smart contract is re-used with a different name but the constructor function isn't also changed it simply becomes a regular, callable function. Similarly, it's possible for an attacker to create a contract with which a function appears to be the constructor but actually has one character replaced with a similar looking character, e.g. replacing an "l" with a "1", allowing logic to be executed when it's only expected to be executed during contract creation.</p>
<p>Now with modern versions of Solidity, the constructor is defined with the <code>constructor</code> keyword, effectively deprecating this vulnerability. Thus the solution to this problem is simply to use modern Solidity compiler versions.</p>
<h3 id="sources-15"><a class="header" href="#sources-15">Sources</a></h3>
<ul>
<li><a href="https://swcregistry.io/docs/SWC-118">SWC-118</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#constructors">Sigma Prime Blog - Solidity Security Constructors</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="shadowing-state-variables"><a class="header" href="#shadowing-state-variables">Shadowing State Variables</a></h2>
<p>It is possible to use the same variable twice in Solidity, but it can lead to unintended side effects. This is especially difficult regarding working with multiple contracts. Take the following example:</p>
<pre><code>contract SuperContract {
  uint a = 1;
}

contract SubContract is SuperContract {
  uint a = 2;
}
</code></pre>
<p>Here we can see that <code>SubContract</code> inherits <code>SuperContract</code> and the variable <code>a</code> is defined twice with different values. Now say we use <code>a</code> to perform some function in <code>SubContract</code>, functionality inherited from <code>SuperContract</code> will no longer work since the value of <code>a</code> has been modified.</p>
<p>To avoid this vulnerability, it's important we check the entire smart contract system for ambiguities. It's also important to check for compiler warnings, as they can flag these ambiguities so long as they're in the smart contract.</p>
<h3 id="sources-16"><a class="header" href="#sources-16">Sources</a></h3>
<ul>
<li><a href="https://swcregistry.io/docs/SWC-119">SWC-119</a></li>
<li><a href="https://github.com/ethereum/solidity/issues/2563">Solidity Issue #2563</a></li>
<li><a href="https://github.com/ethereum/solidity/issues/973">Solidity Issue #973</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="weak-sources-of-randomness-from-chain-attributes"><a class="header" href="#weak-sources-of-randomness-from-chain-attributes">Weak Sources of Randomness from Chain Attributes</a></h2>
<p>Using chain attributes for randomness, e.g.: <code>block.timestamp</code>, <code>blockhash</code>, and <code>block.difficulty</code> can seem like a good idea since they often produce pseudo-random values. The problem however, is that Ethereum is entirely deterministic and all available on-chain data is public. Chain attributes can either be predicted or manipulated, and should thus never be used for random number generation.</p>
<p>A common solution is to use an oracle solution such as <a href="https://docs.chain.link/vrf/v2/introduction/">Chainlink VRF</a>.</p>
<h3 id="sources-17"><a class="header" href="#sources-17">Sources</a></h3>
<ul>
<li><a href="https://swcregistry.io/docs/SWC-120">SWC Registry: SWC-120</a></li>
<li><a href="https://ethereum.stackexchange.com/questions/419/when-can-blockhash-be-safely-used-for-a-random-number-when-would-it-be-unsafe">When can blockhash be safely used for a random number? When would it be unsafe?</a></li>
<li><a href="https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract">How can I securely generate a random number in my smart contract?</a></li>
<li><a href="https://fravoll.github.io/solidity-patterns/randomness.html">Solidity Patterns: Randomness</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="missing-protection-against-signature-replay-attacks"><a class="header" href="#missing-protection-against-signature-replay-attacks">Missing Protection against Signature Replay Attacks</a></h2>
<p>Sometimes in smart contracts it is necessary to perform signature verification to improve usability and gas cost. However, consideration needs to be taken when implementing signature verification. To protect against Signature Replay Attacks, the contract should only be allowing new hashes to be processed. This prevents malicious users from replaying another users signature multiple times.</p>
<p>To be extra safe with signature verification, follow these recommendations:</p>
<ul>
<li>Store every message hash processed by the contract, then check messages hashes against the existing ones before executing the function.</li>
<li>Include the address of the contract in the hash to ensure that the message is only used in a single contract.</li>
<li>Never generate the message hash including the signature. See <a href="vulnerabilities/./signature-malleability.html">Signature Malleability</a></li>
</ul>
<h3 id="sources-18"><a class="header" href="#sources-18">Sources</a></h3>
<ul>
<li><a href="https://swcregistry.io/docs/SWC-121">SWC-121</a></li>
<li><a href="https://medium.com/cypher-core/replay-attack-vulnerability-in-ethereum-smart-contracts-introduced-by-transferproxy-124bf3694e25">Medium - Replay Attack Vulnerability in Ethereum Smart Contracts</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="requirement-violation"><a class="header" href="#requirement-violation">Requirement Violation</a></h2>
<p>The <code>require()</code> method is meant to validate conditions, such as inputs or contract state variables, or to validate return values from external contract calls. For validating external calls, inputs can be provided by callers, or they can be returned by callees. In the case that an input violation has occurred by the return value of a callee, likely one of two things has gone wrong:</p>
<ul>
<li>There is a bug in the contract that provided the input.</li>
<li>The requirement condition is too strong.</li>
</ul>
<p>To solve this issue, first consider whether the requirement condition is too strong. If necessary, weaken it to allow any valid external input. If the problem isn't the requirement condition, there must be a bug in the contract providing external input. Ensure that this contract is not providing invalid inputs.</p>
<h3 id="sources-19"><a class="header" href="#sources-19">Sources</a></h3>
<ul>
<li><a href="https://swcregistry.io/docs/SWC-123">SWC-123: Requirement Violation (SWC Registry)</a></li>
<li><a href="https://medium.com/blockchannel/the-use-of-revert-assert-and-require-in-solidity-and-the-new-revert-opcode-in-the-evm-1a3a7990e06e">The Use of revert, assert, and require in Solidity, and the New REVERT Opcode in the EVM</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="write-to-arbitrary-storage-location"><a class="header" href="#write-to-arbitrary-storage-location">Write to Arbitrary Storage Location</a></h2>
<p>Only authorized addresses should have access to write to sensitive storage locations. If there isn't proper authorization checks throughout the contract, a malicious user may be able to overwrite sensitive data. However, even if there are authorization checks for writing to sensitive data, an attacker may still be able to overwrite the sensitive data via insensitive data. This could give an attacker access to overwrite important variables such as the contract owner.</p>
<p>To prevent this from occurring, we not only want to protect sensitive data stores with authorization requirements, but we also want to ensure that writes to one data structure cannot inadvertently overwrite entries of another data structure.</p>
<p>For an example, try <a href="https://ethernaut.openzeppelin.com/level/19">Ethernaut - Alien Codex</a>. If it's too hard, see <a href="https://github.com/theNvN/ethernaut-openzeppelin-hacks/blob/main/level_19_Alien-Codex.md">this walkthrough (SPOILER)</a>.</p>
<h3 id="sources-20"><a class="header" href="#sources-20">Sources</a></h3>
<ul>
<li><a href="https://swcregistry.io/docs/SWC-124">SWC-124: Write to Arbitrary Storage Location</a></li>
<li><a href="https://github.com/Arachnid/uscc/tree/master/submissions-2017/doughoyte">USCC 2017 Submission by doughoyte</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hash-collision-when-using-abiencodepacked-with-multiple-variable-length-arguments"><a class="header" href="#hash-collision-when-using-abiencodepacked-with-multiple-variable-length-arguments">Hash Collision when using <code>abi.encodePacked()</code> with Multiple Variable-Length Arguments</a></h1>
<p>In Solidity, the <code>abi.encodePacked()</code> function is used to create tightly packed byte arrays which can then be hashed using <code>keccak256()</code></p>
<p>However, this function can be dangerous when used with multiple variable-length arguments because it can lead to hash collisions. These collisions can potentially be exploited in scenarios such as signature verification, allowing attackers to bypass authorization mechanisms.</p>
<p><strong>Hash Collision</strong> is a situation where two different sets of inputs produce the same hash output. In this context, a hash collision can occur when using <code>abi.encodePacked()</code> with multiple variable-length arguments, allowing an attacker to craft different inputs that produce the same hash.</p>
<h2 id="understanding-the-vulnerability"><a class="header" href="#understanding-the-vulnerability">Understanding the vulnerability</a></h2>
<p>When <code>abi.encodePacked()</code> is used with multiple variable-length arguments (such as arrays and strings), the packed encoding does not include information about the boundaries between different arguments. This can lead to situations where different combinations of arguments result in the same encoded output, causing hash collisions.</p>
<p>For example, consider the following two calls to <code>abi.encodePacked()</code>:</p>
<pre><code>abi.encodePacked(["a", "b"], ["c", "d"])
</code></pre>
<pre><code>abi.encodePacked(["a"], ["b", "c", "d"])
</code></pre>
<p>Both calls could potentially produce the same packed encoding because <code>abi.encodePacked()</code> simply concatenates the elements without any delimiters!</p>
<p>Consider the below example for strings:</p>
<pre><code>abi.encodePacked("foo", "bar") == abi.encodePacked("fo", "obar")
</code></pre>
<p>Strings in Solidity are dynamic types and when they are concatenated using <code>abi.encodePacked()</code>, there is no delimiter between them to mark their boundaries, which can lead to hash collisions.</p>
<p>As a matter of fact, the below warning is taken as it is straight from the <a href="https://docs.soliditylang.org/en/latest/abi-spec.html#non-standard-packed-mode">official solidity language documentation</a> regarding the same.</p>
<blockquote>
<p>[!WARNING]
If you use <code>keccak256(abi.encodePacked(a, b))</code> and both <code>a</code> and <code>b</code> are dynamic types, it is easy to craft collisions in the hash value by moving parts of <code>a</code> into <code>b</code> and vice-versa.
More specifically, <code>abi.encodePacked("a", "bc") == abi.encodePacked("ab", "c")</code>. If you use <code>abi.encodePacked</code> for signatures, authentication or data integrity, make sure to always use the same types and check that at most one of them is dynamic. Unless there is a compelling reason, <code>abi.encode</code> should be preferred.</p>
</blockquote>
<h2 id="sample-code-analysis"><a class="header" href="#sample-code-analysis">Sample Code Analysis</a></h2>
<pre><code class="language-solidity">/// INSECURE
function addUsers(address[] calldata admins, address[] calldata regularUsers, bytes calldata signature) external {
    if (!isAdmin[msg.sender]) {
        bytes32 hash = keccak256(abi.encodePacked(admins, regularUsers));
        address signer = hash.toEthSignedMessageHash().recover(signature);
        require(isAdmin[signer], "Only admins can add users.");
    }
    for (uint256 i = 0; i &lt; admins.length; i++) {
        isAdmin[admins[i]] = true;
    }
    for (uint256 i = 0; i &lt; regularUsers.length; i++) {
        isRegularUser[regularUsers[i]] = true;
    }
}
</code></pre>
<p>In the provided sample code above, the <code>addUsers</code> function uses <code>abi.encodePacked(admins, regularUsers)</code> to generate a hash. An attacker could exploit this by rearranging elements between the <code>admins</code> and <code>regularUsers</code> arrays, resulting in the same hash and thereby bypassing authorization checks.</p>
<pre><code class="language-solidity">/// INSECURE
function verifyMessage(string calldata message1, string calldata message2, bytes calldata signature) external {
    bytes32 hash = keccak256(abi.encodePacked(message1, message2));
    address signer = hash.toEthSignedMessageHash().recover(signature);
    require(isAuthorized[signer], "Unauthorized signer");
}
</code></pre>
<p>The above function <code>verifyMessage()</code> could easily be exploited as below:-</p>
<pre><code>verifyMessage("hello", "world", signature);
</code></pre>
<p>or</p>
<pre><code>verifyMessage("hell", "oworld", signature);
</code></pre>
<p>or a variation of the string <code>hello</code> <code>world</code></p>
<p>All variations of the string <code>hello</code> <code>world</code> passed to <code>verifyMessage()</code> would produce the same hash, potentially allowing an attacker to bypass the authorization check if they can provide a valid signature for their manipulated inputs.</p>
<p><strong>Fixed Code Using Single User:</strong></p>
<pre><code class="language-solidity">function addUser(address user, bool admin, bytes calldata signature) external {
    if (!isAdmin[msg.sender]) {
        bytes32 hash = keccak256(abi.encodePacked(user));
        address signer = hash.toEthSignedMessageHash().recover(signature);
        require(isAdmin[signer], "Only admins can add users.");
    }
    if (admin) {
        isAdmin[user] = true;
    } else {
        isRegularUser[user] = true;
    }
}
</code></pre>
<p>This approach eliminates the use of variable-length arrays, thus avoiding the hash collision issue entirely by dealing with a single user at a time.</p>
<p><strong>Fixed Code Using Fixed-Length Arrays:</strong></p>
<pre><code class="language-solidity">function addUsers(address[3] calldata admins, address[3] calldata regularUsers, bytes calldata signature) external {
    if (!isAdmin[msg.sender]) {
        bytes32 hash = keccak256(abi.encodePacked(admins, regularUsers));
        address signer = hash.toEthSignedMessageHash().recover(signature);
        require(isAdmin[signer], "Only admins can add users.");
    }
    for (uint256 i = 0; i &lt; admins.length; i++) {
        isAdmin[admins[i]] = true;
    }
    for (uint256 i = 0; i &lt; regularUsers.length; i++) {
        isRegularUser[regularUsers[i]] = true;
    }
}
</code></pre>
<p>In this version, fixed-length arrays are used, which mitigates the risk of hash collisions since the encoding is unambiguous.</p>
<h2 id="remediation-strategies"><a class="header" href="#remediation-strategies">Remediation Strategies</a></h2>
<p>To prevent this type of hash collision, the below remediation strategies can be employed:</p>
<ol>
<li>
<p><strong>Avoid Variable-Length Arguments</strong>: Avoid using <code>abi.encodePacked()</code> with variable-length arguments such as arrays and strings. Instead, use fixed-length arrays to ensure the encoding is unique and unambiguous.</p>
</li>
<li>
<p><strong>Use <code>abi.encode()</code> Instead</strong>: Unlike <code>abi.encodePacked()</code>, <code>abi.encode()</code> includes additional type information and length prefixes in the encoding, making it much less prone to hash collisions. Switching from <code>abi.encodePacked()</code> to <code>abi.encode()</code> is a simple yet effective fix.</p>
</li>
</ol>
<blockquote>
<p>[!IMPORTANT]
Replay Protection does not protect against possible hash collisions!</p>
<p>It is listed here as a defense in depth strategy and SHOULD NOT be solely relied upon to protect against said vulnerability</p>
</blockquote>
<ol start="3">
<li><strong>Replay Protection</strong>: Implement replay protection mechanisms to prevent attackers from reusing valid signatures. This can involve including nonces or timestamps in the signed data. However, this does not completely eliminate the risk of hash collisions but adds an additional layer of security. More on this can be found <a href="vulnerabilities/./missing-protection-signature-replay.html">here</a></li>
</ol>
<h2 id="sources-21"><a class="header" href="#sources-21">Sources</a></h2>
<ul>
<li><a href="https://swcregistry.io/docs/SWC-133/">Smart Contract Weakness Classification #133</a></li>
<li><a href="https://docs.soliditylang.org/en/latest/abi-spec.html#non-standard-packed-mode">Solidity Non-standard Packed Mode</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="incorrect-inheritance-order"><a class="header" href="#incorrect-inheritance-order">Incorrect Inheritance Order</a></h2>
<p>In Solidity, it is possible to inherit from multiple sources, which if not properly understood can introduce ambiguity. This ambiguity is known as the Diamond Problem, wherein if two base contracts have the same function, which one should be prioritized? Luckily, Solidity handles this problem gracefully, that is as long as the developer understands the solution.</p>
<p>The solution Solidity provides to the Diamond Problem is by using reverse C3 linearization. This means that it will linearize the inheritance from right to left, so the order of inheritance matters. It is suggested to start with more general contracts and end with more specific contracts to avoid problems.</p>
<h3 id="sources-22"><a class="header" href="#sources-22">Sources</a></h3>
<ul>
<li><a href="https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/complex-inheritance/">Consensys: Smart Contract Best Practices - Complex Inheritance</a></li>
<li><a href="https://solidity.readthedocs.io/en/v0.4.25/contracts.html#multiple-inheritance-and-linearization">Solidity Documentation: Multiple Inheritance and Linearization</a></li>
<li><a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">Wikipedia: The Diamond Problem</a></li>
<li><a href="https://en.wikipedia.org/wiki/C3_linearization">Wikipedia: C3 Linearization</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="presence-of-unused-variables"><a class="header" href="#presence-of-unused-variables">Presence of Unused Variables</a></h2>
<p>Although it is allowed, it is best practice to avoid unused variables. Unused variables can lead to a few different problems:</p>
<ul>
<li>Increase in computations (unnecessary gas consumption)</li>
<li>Indication of bugs or malformed data structures</li>
<li>Decreased code readability</li>
</ul>
<p>It is highly recommended to remove all unused variables from a code base.</p>
<h3 id="sources-23"><a class="header" href="#sources-23">Sources</a></h3>
<ul>
<li><a href="https://swcregistry.io/docs/SWC-131">SWC-131: Missing Protection Against Signature Replay Attacks</a></li>
<li><a href="https://github.com/ethereum/solidity/issues/718">Solidity Issue #718</a></li>
<li><a href="https://github.com/ethereum/solidity/issues/2563">Solidity Issue #2563</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unencrypted-private-data-on-chain"><a class="header" href="#unencrypted-private-data-on-chain">Unencrypted Private Data On-Chain</a></h2>
<p>Ethereum smart contract code, storage, and any data transacted on-chain can always be read. Treat it as such. Even if your code is not verified on Etherscan, attackers can still decompile or check transactions to and from it to analyze it. For this reason, it's imperative that private data is never stored on-chain unencrypted.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>Let's consider a scenario where players participate in an Odd or Even game. Each player submits a number, and the winner is determined by the sum of both numbers being odd or even. Here is a vulnerable implementation:</p>
<pre><code class="language-solidity">// Vulnerable contract storing unencrypted private data
contract OddEven {
    struct Player { 
        address payable addr; 
        uint number;
    }
   
    Player[2] private players;
    uint8 count = 0; 

    function play(uint number) public payable {
        require(msg.value == 1 ether);
        players[count] = Player(payable(msg.sender), number);
        count++;
        if (count == 2) selectWinner();
    }
   
    function selectWinner() private {
        uint n = players[0].number + players[1].number;
        players[n % 2].addr.transfer(address(this).balance);
        delete players;
        count = 0;
    }
}
</code></pre>
<p>In this contract, the <code>players</code> array stores the submitted numbers in plain text. Although the <code>players</code> array is marked as private, this only means it is not accessible via other smart contracts. However, anyone can read the blockchain and view the stored values. This means the first player's number will be visible, allowing the second player to select a number that they know will make them a winner.</p>
<h3 id="protection-mechanisms"><a class="header" href="#protection-mechanisms">Protection Mechanisms</a></h3>
<p>To protect sensitive data, consider the following strategies:</p>
<ol>
<li>Commit-Reveal Scheme: Use a commit-reveal scheme where the data is committed to the blockchain in one phase and revealed in another.</li>
<li>Zero-Knowledge Proofs: Use cryptographic techniques such as zero-knowledge proofs to validate data without revealing it.</li>
</ol>
<h3 id="references"><a class="header" href="#references">References</a></h3>
<ul>
<li><a href="https://medium.com/@natachigram/attack-vectors-in-solidity-4-unencrypted-private-data-on-chain-cf4f3ff1cf71">Medium Article: Attack Vectors in Solidity #4: Unencrypted Private Data On-Chain</a></li>
<li><a href="https://solidity-by-example.org/hacks/accessing-private-data/">Solidity by Example: Accessing Private Data</a></li>
<li><a href="https://swcregistry.io/docs/SWC-136">SWC Registry: Unencrypted Private Data On-Chain</a></li>
<li><a href="https://blog.ethereum.org/2016/12/05/zksnarks-in-a-nutshell/">Zero-Knowledge Proofs</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="inadherence-to-standards"><a class="header" href="#inadherence-to-standards">Inadherence to Standards</a></h2>
<p>In terms of smart contract development, it's important to follow standards. Standards are set to prevent vulnerabilities, and ignoring them can lead to unexpected effects.</p>
<p>Take for example binance's original BNB token. It was marketed as an ERC20 token, but it was later pointed out that it wasn't actually ERC20 compliant for a few reasons:</p>
<ul>
<li>It prevented sending to 0x0</li>
<li>It blocked transfers of 0 value</li>
<li>It didn't return true or false for success or fail</li>
</ul>
<p>The main cause for concern with this improper implementation is that if it is used with a smart contract that expects an ERC-20 token, it will behave in unexpected ways. It could even get locked in the contract forever.</p>
<p>Although standards aren't always perfect, and may someday become antiquated, they foster proper expectations to provide for secure smart contracts.</p>
<p>Suggested by: <a href="https://github.com/RobertMCForster">RobertMCForster</a></p>
<h3 id="sources-24"><a class="header" href="#sources-24">Sources</a></h3>
<ul>
<li><a href="https://finance.yahoo.com/news/bnb-really-erc-20-token-160013314.html">BNB: Is It Really an ERC-20 Token?</a></li>
<li><a href="https://blog.goodaudience.com/binance-isnt-erc-20-7645909069a4">Binance Isn't ERC-20</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="asserting-contract-from-code-size"><a class="header" href="#asserting-contract-from-code-size">Asserting contract from Code Size</a></h2>
<p>A common method for asserting whether a sender is a contract or EOA has been to check the code size of the sender. This check asserts that if the sender has a code size &gt; 0 that it must be a contract and if not then it must be an EOA. For example:</p>
<pre><code>function mint(uint256 amount) public {
  if (msg.sender.code.length != 0) revert CallerNotEOA();
}
</code></pre>
<p>However, as noted in the <a href="https://ethereum.github.io/yellowpaper/paper.pdf">Ethereum Yellow Paper</a>, "During initialization code execution, EXTCODESIZE on the address should return zero, which is the length of the code of the account while CODESIZE should return the length of the initialization".</p>
<p><a href="https://github.com/0xKitsune/Ghost-Contract/blob/main/src/Ghost.sol">This repo</a> shows how we may exploit this logic by simply calling during creation of a new contract.</p>
<p>As we can see, it's important that we recognize that although we may be certain that an account with a non-zero codesize is a contract, we can't be certain that an account with a zero codesize is not a contract.</p>
<h3 id="sources-25"><a class="header" href="#sources-25">Sources</a></h3>
<ul>
<li><a href="https://ethereum.github.io/yellowpaper/paper.pdf">Ethereum Yellow Paper</a></li>
<li><a href="https://github.com/0xKitsune/Ghost-Contract">Ghost Contract on GitHub</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="transaction-ordering-dependence"><a class="header" href="#transaction-ordering-dependence">Transaction-Ordering Dependence</a></h2>
<p>Transactions on Ethereum are grouped together in blocks which are processed on a semi-regular interval, 12 seconds. Before transactions are placed in blocks, they are broadcasted to the mempool where block builders can then proceed to place them as is economically optimal. What's important to understand here is that the mempool is public and thus anyone can see transactions before they're executed, giving them the power to frontrun by placing their own transaction executing the same, or a similar, action with a higher gas price.</p>
<p>Frontrunning has become prevalent as a result of generalized frontrunning bots becoming more and more common. These generalized frontrunners work by observing the mempool for profitable, replicable transactions which they can replace for their own benefit. <a href="https://www.paradigm.xyz/2020/08/ethereum-is-a-dark-forest">Ethereum is a Dark Forest</a>.</p>
<p>One solution to transaction-ordering dependence is to use a commit-reveal scheme in the case of information being submitted on-chain. This works by having the submitter send in a hash of the information, storing that on-chain along with the user address so that they may later reveal the answer along with the salt to prove that they were indeed correct. Another solution is to simply use a private mempool such as <a href="https://www.flashbots.net/">Flashbots</a>.</p>
<h3 id="sources-26"><a class="header" href="#sources-26">Sources</a></h3>
<ul>
<li><a href="https://medium.com/coinmonks/solidity-transaction-ordering-attacks-1193a014884e">Solidity Transaction Ordering Attacks</a></li>
<li><a href="https://users.encs.concordia.ca/~clark/papers/2019_wtsc_front.pdf">Analysis of Transaction Ordering in Ethereum</a></li>
<li><a href="https://swcregistry.io/docs/SWC-114">SWC-114: Transaction Order Dependence</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="dos-with-block-gas-limit"><a class="header" href="#dos-with-block-gas-limit">DoS with Block Gas Limit</a></h2>
<p>One of the primary benefits of a block gas limit is that it prevents attackers from creating an infinite transaction loop. If the gas usage of a transaction exceeds this limit, the transaction will fail. However, along with this benefit comes a side effect which is important to understand.</p>
<h3 id="unbounded-operations"><a class="header" href="#unbounded-operations">Unbounded Operations</a></h3>
<p>An example in which the block gas limit can be an issue is in executing logic in an unbounded loop. Even without any malicious intent, this can easily go wrong. Just by e.g., having too large an array of users to send funds to can exceed the gas limit and prevent the transaction from ever succeeding, potentially permanently locking up funds.</p>
<p>This situation can also lead to an attack. Say a bad actor decides to create a significant amount of addresses, with each address being paid a small amount of funds from the smart contract. If done effectively, the transaction can be blocked indefinitely, possibly even preventing further transactions from going through.</p>
<p>An effective solution to this problem would be to use a pull payment system over the above push payment system. To do this, separate each payment into its own transaction, and have the recipient call the function.</p>
<p>If, for some reason, you really need to loop through an array of unspecified length, at least expect it to potentially take multiple blocks, and allow it to be performed in multiple transactions - as seen in this example:</p>
<pre><code>struct Payee {
    address addr;
    uint256 value;
}

Payee[] payees;
uint256 nextPayeeIndex;

function payOut() {
    uint256 i = nextPayeeIndex;
    while (i &lt; payees.length &amp;&amp; msg.gas &gt; 200000) {
      payees[i].addr.send(payees[i].value);
      i++;
    }
    nextPayeeIndex = i;
}
</code></pre>
<h3 id="block-stuffing"><a class="header" href="#block-stuffing">Block Stuffing</a></h3>
<p>In some situations, your contract can be attacked with a block gas limit even if you don't loop through an array of unspecified length. An attacker can fill several blocks before a transaction can be processed by using a sufficiently high gas price.</p>
<p>This attack is done by issuing several transactions at a very high gas price. If the gas price is high enough, and the transactions consume enough gas, they can fill entire blocks and prevent other transactions from being processed.</p>
<p>Ethereum transactions require the sender to pay gas to disincentivize spam attacks, but in some situations, there can be enough incentive to go through with such an attack. For example, a block stuffing attack was used on a gambling Dapp, Fomo3D. The app had a countdown timer, and users could win a jackpot by being the last to purchase a key, except every time a user bought a key, the timer would be extended. An attacker bought a key then stuffed the next 13 blocks in a row so they could win the jackpot.</p>
<p>To prevent such attacks from occurring, it's important to carefully consider whether it's safe to incorporate time-based actions in your application.</p>
<p>Example from: <a href="https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service/">https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service/</a></p>
<h3 id="sources-27"><a class="header" href="#sources-27">Sources</a></h3>
<ul>
<li><a href="https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service/">Consensys Smart Contract Best Practices - Denial of Service</a></li>
<li><a href="https://ethereum.org/en/developers/docs/gas/">Ethereum Developers Documentation - Gas</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="dos-with-unexpected-revert"><a class="header" href="#dos-with-unexpected-revert">DoS with (Unexpected) revert</a></h2>
<p>A DoS (Denial of Service) may be caused when logic is unable to be executed as a result of an unexpected revert. This can happen for a number of reasons and it's important to consider all the ways in which your logic may revert. The examples listed below are <em>non-exhaustive</em>.</p>
<h3 id="reverting-funds-transfer"><a class="header" href="#reverting-funds-transfer">Reverting funds transfer</a></h3>
<p>DoS (Denial of Service) attacks can occur in functions when you try to send funds to a user and the functionality relies on that fund transfer being successful.</p>
<p>This can be problematic in the case that the funds are sent to a smart contract created by a bad actor, since they can simply create a fallback function that reverts all payments.</p>
<p>For example:</p>
<pre><code>// INSECURE
contract Auction {
    address currentLeader;
    uint highestBid;

    function bid() payable {
        require(msg.value &gt; highestBid);

        require(currentLeader.send(highestBid)); // Refund the old leader, if it fails then revert

        currentLeader = msg.sender;
        highestBid = msg.value;
    }
}
</code></pre>
<p>As you can see in this example, if an attacker bids from a smart contract with a fallback function reverting all payments, they can never be refunded, and thus no one can ever make a higher bid.</p>
<p>This can also be problematic without an attacker present. For example, you may want to pay an array of users by iterating through the array, and of course you would want to make sure each user is properly paid. The problem here is that if one payment fails, the function is reverted and no one is paid.</p>
<pre><code>address[] private refundAddresses;
mapping (address =&gt; uint) public refunds;

// bad
function refundAll() public {
    for(uint x; x &lt; refundAddresses.length; x++) { // arbitrary length iteration based on how many addresses participated
        require(refundAddresses[x].send(refunds[refundAddresses[x]])) // doubly bad, now a single failure on send will hold up all funds
    }
}
</code></pre>
<p>An effective solution to this problem would be to use a pull payment system over the above push payment system. To do this, separate each payment into its own transaction, and have the recipient call the function.</p>
<pre><code>contract auction {
    address highestBidder;
    uint highestBid;
    mapping(address =&gt; uint) refunds;

    function bid() payable external {
        require(msg.value &gt;= highestBid);

        if (highestBidder != address(0)) {
            refunds[highestBidder] += highestBid; // record the refund that this user can claim
        }

        highestBidder = msg.sender;
        highestBid = msg.value;
    }

    function withdrawRefund() external {
        uint refund = refunds[msg.sender];
        refunds[msg.sender] = 0;
        (bool success, ) = msg.sender.call.value(refund)("");
        require(success);
    }
}
</code></pre>
<p>Examples from: https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service/
https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/external-calls/</p>
<h3 id="overunderflow"><a class="header" href="#overunderflow">Over/Underflow</a></h3>
<p>Prior to SafeMath usage, whether built-in in solidity &gt;=0.8.0 or using a library, <a href="vulnerabilities/./overflow-underflow.html">over/underflows</a> would result in rolling over to the minimum/maximum value. Now that checked math is commonplace, it's important to recognize that the effect of checked under/overflows is a revert, which may DoS important logic.</p>
<p>Regardless of usage of checked math, it's necessary to ensure that any valid input will not result in an over/underflow. Take extra care when working with smaller integers e.g. <code>int8</code>/<code>uint8</code>, <code>int16</code>/<code>uint16</code>, <code>int24</code>/<code>uint24</code>, etc..</p>
<h3 id="unexpected-balance"><a class="header" href="#unexpected-balance">Unexpected Balance</a></h3>
<p>It's important to take caution in enforcing expected contract balances of tokens or Ether as those balances may be increased by an attacker to cause an unexpected revert. This is easily possible with ERC20 tokens by simply <code>transfer</code>ring to the contract, but is also possible with Ether by <a href="vulnerabilities/./forcibly-sending-ether.html">Forcibly sending Ether to a contract</a>.</p>
<p>Consider, for example, a contract which expects the Ether balance to be 0 for the first deposit to allow for custom accounting logic. An attacker may forcibly send Ether to the contract before the first deposit, causing all deposits to revert.</p>
<h3 id="divide-by-zero"><a class="header" href="#divide-by-zero">Divide by Zero</a></h3>
<p>In solidity if the contract attempts to perform division when the denominator is <code>zero</code>, the call reverts. Thus, the denominator should be always checked before division to prevent DoS revert.</p>
<pre><code class="language-solidity">function foo(uint num, uint den) public pure returns(uint result) {
  result = num / den; // if den = 0, the execution reverts
}
</code></pre>
<h3 id="sources-28"><a class="header" href="#sources-28">Sources</a></h3>
<ul>
<li><a href="https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service/">Consensys Smart Contract Best Practices - Denial of Service</a></li>
<li><a href="https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/external-calls/">Consensys Smart Contract Best Practices - External Calls</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unexpected-ecrecover-null-address"><a class="header" href="#unexpected-ecrecover-null-address">Unexpected <code>ecrecover</code> Null Address</a></h2>
<p><code>ecrecover</code> is a precompiled built-in cryptographic function which recovers an address associated with the public key from an elliptic curve signature or <em>returns zero on error</em>. The parameters corresponding to the signature are <code>r</code>, <code>s</code> &amp; <code>v</code>.</p>
<p>As noted above, <code>ecrecover</code> will return zero on error. It's possible to do this deterministically by setting <code>v</code> as any positive number other than 27 or 28.</p>
<p><code>ecrecover</code> is often used to verify that the signer is an authorized account. The problem with this is that uninitialized or renounced authorization logic often sets the owner/admin address as <code>address(0)</code>, the same value which may be deterministically returned by <code>ecrecover</code>. This means that an unsecure contract may allow an attacker to spoof an authorized-only method into executing as though the authorized account is the signer.</p>
<pre><code>// UNSECURE
function setOwner(bytes32 newOwner, uint8 v, bytes32 r, bytes32 s) external {
	address signer = ecrecover(newOwner, v, r, s);
	require(signer == owner);
	owner = address(newOwner);
}
</code></pre>
<p>The above method is intended to only set a new <code>owner</code> if a valid signature from the existing <code>owner</code> is provided. However, as we know, if we set <code>v</code> to any value other than 27 or 28, the <code>signer</code> will be the null address and if the current owner is uninitialized or renounced, the <code>require</code> statement will succeed allowing an attacker to set themselves as <code>owner</code>.</p>
<p>We can mitigate this issue by reverting if the recovered <code>signer</code> address is null, e.g.:</p>
<pre><code>function setOwner(bytes32 newOwner, uint8 v, bytes32 r, bytes32 s) external {
	address signer = ecrecover(newOwnerHash, v, r, s);
	require(signer == owner &amp;&amp; signer != address(0));
	owner = address(newOwner);
}
</code></pre>
<h3 id="sources-29"><a class="header" href="#sources-29">Sources</a></h3>
<ul>
<li><a href="https://docs.soliditylang.org/en/latest/units-and-global-variables.html#mathematical-and-cryptographic-functions">Solidity Documentation: Mathematical and Cryptographic Functions</a></li>
<li><a href="https://ethereum.stackexchange.com/a/69329">Ethereum Stack Exchange Answer</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="default-visibility"><a class="header" href="#default-visibility">Default Visibility</a></h2>
<p>Visibility specifiers are used to determine where a function or variable can be accessed from. As explained in the <a href="https://docs.soliditylang.org/en/v0.8.15/cheatsheet.html?highlight=visibility#function-visibility-specifiers">solidity docs</a>:</p>
<ul>
<li><code>public</code>: visible externally and internally (creates a <a href="https://docs.soliditylang.org/en/v0.8.15/contracts.html#getter-functions">getter function</a> for storage/state variables)</li>
<li><code>private</code>: only visible in the current contract</li>
<li><code>external</code>: only visible externally (only for functions) - i.e. can only be message-called (via <code>this.func</code>)</li>
<li><code>internal</code>: only visible internally</li>
</ul>
<p>It's important to note that the default visibility is <code>public</code>, allowing access externally or internally by any contract or EOA. We can see how this may be a problem if a method is intended to only be accessible internally but is missing a visibility specifier.</p>
<p>Modern compilers should catch missing function visibility specifiers, but will generally allow missing state variable visibility specifiers. Regardless, it's important to be aware of the possible interactions which may occur as a result of default visibility specifiers for both functions and state variables.</p>
<h3 id="sources-30"><a class="header" href="#sources-30">Sources</a></h3>
<ul>
<li><a href="https://swcregistry.io/docs/SWC-100">SWC-100</a></li>
<li><a href="https://swcregistry.io/docs/SWC-108">SWC-108</a></li>
<li><a href="https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/visibility/">Consensys Smart Contract Best Practices - Visibility</a></li>
<li><a href="https://github.com/sigp/solidity-security-blog#visibility">SigP Solidity Security Blog - Visibility</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="insufficient-access-control"><a class="header" href="#insufficient-access-control">Insufficient Access Control</a></h2>
<p>Access control is often imperative in management and ownership of smart contracts. It's important to consider ways in which access control may be circumvented, or insufficiently implemented and the corresponding consequences.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="off-by-one"><a class="header" href="#off-by-one">Off-By-One</a></h2>
<p>Off-by-one errors are a common mistake made by programmers in which the intended boundaries are incorrect by only one, though these errors may seem insignificant, the effect can easily be quite severe.</p>
<h3 id="array-lengths"><a class="header" href="#array-lengths">Array lengths</a></h3>
<p>Properly determining intended array lengths is a common source of off-by-one errors. Particularly since 0-indexing means the final value in an array is <code>array.length - 1</code>.</p>
<p>Consider for example a function intended to loop over a list of recipients to transfer funds to each user, but the loop length is incorrectly set.</p>
<pre><code>// Incorrectly sets upper bound to users.length - 1
// Final user in array doesn't receive token transfer
for (uint256 i; i &lt; users.length - 1; ++i) {
	token.transfer(users[i], 1 ether);
}
</code></pre>
<h3 id="incorrect-comparison-operator"><a class="header" href="#incorrect-comparison-operator">Incorrect comparison operator</a></h3>
<p>It's common for comparison operators to be off by one when, e.g. <code>&gt;</code> should be used in place of <code>&gt;=</code>. This is especially common when the logic includes some kind of negation, leading to mental friction in deciphering the intended vs implemented bounds.</p>
<p>Consider for example a Defi protocol with liquidation logic documented to liquidate a user only if their collateralization ratio is <em>below</em> 1e18.</p>
<pre><code>// Incorrectly liquidates if collateralizationRatio is == 1 ether
if (collateralizationRatio &gt; 1 ether) {
	...
} else {
	liquidate();
}
</code></pre>
<h3 id="sources-31"><a class="header" href="#sources-31">Sources</a></h3>
<ul>
<li><a href="https://github.com/OpenCoreCH/smart-contract-auditing-heuristics#off-by-one-errors">OpenCoreCH - Smart Contract Auditing Heuristics: Off-by-One Errors</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="lack-of-precision"><a class="header" href="#lack-of-precision">Lack of Precision</a></h2>
<p>In Solidity, there are a limited variety of number types. Differently from many programming languages, floating point numbers are unsupported. Fixed point numbers are partially supported, but cannot be assigned to or from. The primary number type in Solidity are integers, of which resulting values of calculations are always rounded down.</p>
<p>Since division often results in a remainder, performing division with integers generally requires a lack of precision to some degree. To see how a lack of precision may cause a serious flaw, consider the following example in which we charge a fee for early withdrawals denominated in the number of days early that the withdrawal is made:</p>
<pre><code>uint256 daysEarly = withdrawalsOpenTimestamp - block.timestamp / 1 days
uint256 fee = amount / daysEarly * dailyFee
</code></pre>
<p>The problem with this is that in the case that a user withdraws 1.99 days early, since 1.99 will round down to 1, the user only pays about half the intended fee.</p>
<p>In general, we should ensure that numerators are sufficiently larger than denominators to avoid precision errors. A common solution to this problem is to use fixed point logic, i.e. raising integers to a sufficient number of decimals such that the lack of precision has minimal effect on the contract logic. A good rule of thumb is to raise numbers to 1e18 (commonly referred to as WAD).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unbounded-return-data"><a class="header" href="#unbounded-return-data">Unbounded Return Data</a></h2>
<p>The <a href="https://blog.ethereum.org/2017/10/12/byzantium-hf-announcement">Byzantium</a> 2017 mainnet hard-fork introduced <a href="https://eips.ethereum.org/EIPS/eip-211">EIP-211</a>. This EIP established an arbitrary-length return data buffer as well as 2 new opcodes: <code>RETURNDATASIZE</code> and <code>RETURNDATACOPY</code>. This enables callers to copy all or part of the return data from an external call to memory. The variable length buffer is created empty for each new call-frame. Previously, the size of the return data had to be specified in advance in the call parameters.</p>
<p>However under Solidity's implementation, up until at least <code>0.8.26</code>, the entirety of this return data is automatically copied from the buffer into memory. This is true even when using a Solidity low-level call with the omission of the <code>bytes memory data</code> syntax.</p>
<p>Consider the following example:</p>
<pre><code class="language-solidity">pragma solidity 0.8.26;

contract Attacker {
    function returnExcessData() external pure returns (string memory) {
        revert("Passing in excess data that the Solidity compiler will automatically copy to memory");   // Both statements can return unbounded data
        return "Passing in excess data that the Solidity compiler will automatically copy to memory";
    }
}


contract Victim {
    function callAttacker(address attacker) external returns (bool) {
        (bool success, ) = attacker.call{gas: 2500}(abi.encodeWithSignature("returnExcessData()"));
        return success;
    }
}
</code></pre>
<p>In the above example one can observe that even though the <code>Victim</code> contract has not explicitly requested <code>bytes memory data</code> to be returned, and has furthermore given the external call a gas stipend of 2500, Solidity will still invoke <code>RETURNDATACOPY</code> during the top-level call-frame. This means the <code>Attacker</code> contract, through revert or return, can force the <code>Victim</code> contract to consume unbounded gas during their own call-frame and not that of the <code>Attacker</code>. Given that memory gas costs grow exponentially after 23 words, this attack vector has the potential to prevent certain contract flows from being executed due to an <code>Out of Gas</code> error. Examples of vulnerable contract flows include unstaking or undelegating funds where a callback is involved. Here the user may be prevented from unstaking or undelegating their funds, because the transaction reverts due to insufficient gas.</p>
<h3 id="mitigation-1"><a class="header" href="#mitigation-1">Mitigation</a></h3>
<p>The recommended mitigation approach is to use Yul to make the low-level call, whilst only allowing bounded return data. This method completely cuts off the attack vector for any arbitrary external call.</p>
<p>Consider the following example from EigenLayer's original mainnet <code>DelegationManager.sol</code> contract. In this contract, delegators could delegate and undelegate their restaked assets to a manager, and each of these delegation flows had its own callback hook to an arbitrary external contract the manager specified. However the manager could use their arbitrary external contract to return unbounded data, causing the delegator to run out of gas, and thus not be able to undelegate their assets from that manager.</p>
<p>Therefore to mitigate this griefing risk entirely, EigenLayer used a Yul call, where they limit the return data size to 1 word. If the external manager contract tries to return any more data than this, the excess of 32 bytes simply won't be copied to memory.</p>
<pre><code class="language-solidity">    function _delegationWithdrawnHook(
        IDelegationTerms dt,
        address staker,
        IStrategy[] memory strategies,
        uint256[] memory shares
    )
        internal
    {
        /**
         * We use low-level call functionality here to ensure that an operator cannot maliciously make this function fail in order to prevent undelegation.
         * In particular, in-line assembly is also used to prevent the copying of uncapped return data which is also a potential DoS vector.
         */
        // format calldata
        bytes memory lowLevelCalldata = abi.encodeWithSelector(IDelegationTerms.onDelegationWithdrawn.selector, staker, strategies, shares);
        // Prepare memory for low-level call return data. We accept a max return data length of 32 bytes
        bool success;
        bytes32[1] memory returnData;
        // actually make the call
        assembly {
            success := call(
                // gas provided to this context
                LOW_LEVEL_GAS_BUDGET,
                // address to call
                dt,
                // value in wei for call
                0,
                // memory location to copy for calldata
                add(lowLevelCalldata, 32),
                // length of memory to copy for calldata
                mload(lowLevelCalldata),
                // memory location to copy return data
                returnData,
                // byte size of return data to copy to memory
                32
            )
        }
        // if the call fails, we emit a special event rather than reverting
        if (!success) {
            emit OnDelegationWithdrawnCallFailure(dt, returnData[0]);
        }
    }
</code></pre>
<h3 id="sources-32"><a class="header" href="#sources-32">Sources</a></h3>
<ul>
<li><a href="https://github.com/ethereum/solidity/issues/12306">Solidity Issue #12306</a></li>
<li><a href="https://github.com/nomad-xyz/ExcessivelySafeCall">ExcessivelySafeCall Repository</a></li>
<li><a href="https://github.com/Layr-Labs/eigenlayer-contracts/blob/0139d6213927c0a7812578899ddd3dda58051928/src/contracts/core/DelegationManager.sol#L259-L299">DelegationManager.sol (lines 259-299)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="using-msgvalue-in-a-loop"><a class="header" href="#using-msgvalue-in-a-loop">Using <code>msg.value</code> in a Loop</a></h2>
<p>The value of <code>msg.value</code> in a transaction’s call never gets updated, even if the called contract ends up sending some or all of the ETH to another contract. This means that using <code>msg.value</code> in <code>for</code> or <code>while</code> loops, without extra accounting logic, will either lead to the transaction reverting (when there are no longer sufficient funds for later iterations), or to the contract being drained (when the contract itself has an ETH balance).</p>
<pre><code class="language-solidity">contract depositer {
    function deposit(address weth) payable external {
        for (uint i = 0; i &lt; 5; i ++) {
            WETH(weth).deposit{value: msg.value}();
        }
    }
}
</code></pre>
<p>In the above example, first iteration will use all the <code>msg.value</code> for the external call and all other iterations can:</p>
<ul>
<li>Drain the contract if enough ETH balance exists inside the contract to cover all the iterations.</li>
<li>Revert if enough ETH balance doesn't exist inside the contract to cover all the iterations.</li>
<li>Succeed if the external implementation succeeds with zero value transfers.</li>
</ul>
<p>Also, if a function has a check like <code>require(msg.value == 1e18, "Not Enough Balance")</code>, that function can be called multiple times in a same transaction by sending <code>1 ether</code> once as <code>msg.value</code> is not updated in a transaction call.</p>
<pre><code class="language-solidity">function batchBuy(address[] memory addr) external payable{
    mapping (uint =&gt; address) nft;

    for (uint i = 0; i &lt; addr.length; i++) {
         buy1NFT(addr[i])
    }

    function buy1NFT(address to) internal {
         if (msg.value &lt; 1 ether) { // buy unlimited times after sending 1 ether once
            revert("Not enough ether");
            } 
         nft[numero] = address;
    }
}
</code></pre>
<p>Thus, using <code>msg.value</code> inside a loop is dangerous because this might allow the sender to <code>re-use</code> the <code>msg.value</code>.</p>
<p>Reuse of <code>msg.value</code> can also show up with payable multicalls. Multicalls enable a user to submit a list of transactions to avoid paying the 21,000 gas transaction fee over and over. However, If <code>msg.value</code> gets <code>re-used</code> while looping through the functions to execute, it can cause a serious issue like the <a href="https://peckshield.medium.com/opyn-hacks-root-cause-analysis-c65f3fe249db">Opyn Hack</a>.</p>
<h3 id="sources-33"><a class="header" href="#sources-33">Sources</a></h3>
<ul>
<li><a href="https://www.rareskills.io/post/smart-contract-security#:~:text=Using%20msg.,show%20up%20with%20payable%20multicalls.">Rare Skills - Smart Contract Security</a></li>
<li><a href="https://trustchain.medium.com/ethereum-msg-value-reuse-vulnerability-5afd0aa2bcef">TrustChain - Ethereum msg.value Reuse Vulnerability</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="deleting-a-mapping-within-a-struct"><a class="header" href="#deleting-a-mapping-within-a-struct">Deleting a Mapping Within a Struct</a></h2>
<p>It is a common assumption that deleting a <code>struct</code> will delete all of it's data entirely but there is an exception. Deleting structs with dynamic data types does not delete the data stored inside them.</p>
<p>For example: If a <code>mapping</code> (or dynamic array) is inside a struct, and the struct is deleted, the mapping will not be deleted. This is because mappings are implemented as hash tables and the EVM does not keep track of which keys have been used in the mapping. As a result, EVM doesn't know how to reset a mapping and the remaining data can be used to compromise the contract.</p>
<pre><code class="language-solidity">    struct BalancesStruct{
        address owner;
        mapping(address =&gt; uint) balances;
    }

    mapping(address =&gt; BalancesStruct) public stackBalance;

    function remove() internal{
         delete stackBalance[msg.sender]; // doesn't delete balances mapping inside BalancesStruct
    }
</code></pre>
<p><code>remove()</code> function above deletes an item of <code>stackBalance</code>. But the mapping <code>balances</code> inside <code>BalancesStruct</code> won't reset. Only individual keys and what they map to can be deleted. Example: <code>delete stackBalance[msg.sender].balances[x]</code> will delete the data stored at address <code>x</code> in the balances mapping.</p>
<h3 id="sources-34"><a class="header" href="#sources-34">Sources</a></h3>
<ul>
<li><a href="https://docs.soliditylang.org/en/latest/types.html#delete">Solidity Documentation - Delete</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
